################################################################################
# PATCH #5: ADD INPUT VALIDATION
# Priority: HIGH
# Time to apply: 10 minutes
################################################################################

DESCRIPTION:
Adds comprehensive input validation to prevent malicious or malformed data
from crashing the application or corrupting the database.

FILES TO MODIFY:
1. models.py

DEPENDENCIES:
None - uses Pydantic validators (already included)

################################################################################
# CHANGES TO models.py
################################################################################

# ADD IMPORT AT TOP
# ===========================================================================
from pydantic import field_validator
import re


# UPDATE JobStartRequest
# ===========================================================================
# FIND:
class JobStartRequest(SQLModel):
    job_id: Optional[str] = None
    expected_barcode: str
    pieces_per_shipper: int = 1
    target_quantity: int = 0

# REPLACE WITH:
class JobStartRequest(SQLModel):
    job_id: Optional[str] = None
    expected_barcode: str
    pieces_per_shipper: int = 1
    target_quantity: int = 0
    
    @field_validator('job_id')
    @classmethod
    def validate_job_id(cls, v: Optional[str]) -> Optional[str]:
        """Validate job ID format and content"""
        if v is None:
            return None
        
        v = v.strip()
        if not v:
            return None
        
        # Length check
        if len(v) > 100:
            raise ValueError('Job ID must be 100 characters or less')
        
        # Prevent XSS and SQL injection attempts
        dangerous_chars = ['<', '>', '"', "'", '&', ';', '\\', '/', '\x00']
        if any(char in v for char in dangerous_chars):
            raise ValueError('Job ID contains invalid characters')
        
        # Prevent control characters
        if any(ord(char) < 32 for char in v):
            raise ValueError('Job ID contains control characters')
        
        return v
    
    @field_validator('expected_barcode')
    @classmethod
    def validate_barcode(cls, v: str) -> str:
        """Validate barcode format and content"""
        if not v:
            raise ValueError('Barcode is required')
        
        v = v.strip()
        if not v:
            raise ValueError('Barcode cannot be empty')
        
        # Length check
        if len(v) > 200:
            raise ValueError('Barcode must be 200 characters or less')
        
        # Minimum length (most barcodes are at least 3 chars)
        if len(v) < 1:
            raise ValueError('Barcode is too short')
        
        # Prevent XSS and injection attacks
        dangerous_chars = ['<', '>', '"', "'", '&', ';', '\\', '\x00']
        if any(char in v for char in dangerous_chars):
            raise ValueError('Barcode contains invalid characters')
        
        # Prevent control characters
        if any(ord(char) < 32 and char not in ['\t', '\n', '\r'] for char in v):
            raise ValueError('Barcode contains invalid control characters')
        
        return v
    
    @field_validator('pieces_per_shipper')
    @classmethod
    def validate_pieces(cls, v: int) -> int:
        """Validate pieces per shipper"""
        if v < 1:
            raise ValueError('Pieces per shipper must be at least 1')
        
        if v > 10000:
            raise ValueError('Pieces per shipper must be 10,000 or less')
        
        return v
    
    @field_validator('target_quantity')
    @classmethod
    def validate_target(cls, v: int) -> int:
        """Validate target quantity"""
        if v < 0:
            raise ValueError('Target quantity cannot be negative')
        
        if v > 1000000:
            raise ValueError('Target quantity must be 1,000,000 or less')
        
        return v


# UPDATE ScanRequest
# ===========================================================================
# FIND:
class ScanRequest(SQLModel):
    barcode: str

# REPLACE WITH:
class ScanRequest(SQLModel):
    barcode: str
    
    @field_validator('barcode')
    @classmethod
    def validate_barcode(cls, v: str) -> str:
        """Validate scanned barcode"""
        if not v:
            raise ValueError('Barcode is required')
        
        v = v.strip()
        if not v:
            raise ValueError('Barcode cannot be empty or whitespace only')
        
        # Length check
        if len(v) > 200:
            raise ValueError('Barcode is too long (max 200 characters)')
        
        # Prevent XSS and injection
        dangerous_chars = ['<', '>', '"', "'", '&', ';', '\\', '\x00']
        if any(char in v for char in dangerous_chars):
            raise ValueError('Barcode contains invalid characters')
        
        # Prevent control characters (except common ones)
        if any(ord(char) < 32 and char not in ['\t', '\n', '\r'] for char in v):
            raise ValueError('Barcode contains invalid control characters')
        
        return v


# UPDATE JobEndRequest
# ===========================================================================
# FIND:
class JobEndRequest(SQLModel):
    pin: str

# REPLACE WITH:
class JobEndRequest(SQLModel):
    pin: str
    
    @field_validator('pin')
    @classmethod
    def validate_pin(cls, v: str) -> str:
        """Validate PIN format"""
        if not v:
            raise ValueError('PIN is required')
        
        v = v.strip()
        
        # Length check
        if len(v) < 4:
            raise ValueError('PIN must be at least 4 characters')
        
        if len(v) > 20:
            raise ValueError('PIN must be 20 characters or less')
        
        # Only allow alphanumeric (some PINs might have letters)
        if not re.match(r'^[a-zA-Z0-9]+$', v):
            raise ValueError('PIN must contain only letters and numbers')
        
        return v


################################################################################
# UPDATE FRONTEND VALIDATION (static/js/app.js)
################################################################################

# Add client-side validation to match server-side rules
# This provides better UX and reduces unnecessary API calls

# In app.js, find startJob() function:
# ===========================================================================

async startJob() {
    const expectedBarcode = document.getElementById('expected-barcode')?.value.trim();
    const jobId = document.getElementById('job-id')?.value.trim();
    const targetQty = parseInt(document.getElementById('target-quantity')?.value) || 0;

    // CLIENT-SIDE VALIDATION
    if (!expectedBarcode) {
        alert('Please enter an expected barcode');
        document.getElementById('expected-barcode')?.focus();
        return;
    }
    
    if (expectedBarcode.length > 200) {
        alert('Barcode is too long (max 200 characters)');
        return;
    }
    
    // Check for dangerous characters
    const dangerousPattern = /[<>"'&;\\]/;
    if (dangerousPattern.test(expectedBarcode)) {
        alert('Barcode contains invalid characters');
        return;
    }
    
    if (jobId && jobId.length > 100) {
        alert('Job ID is too long (max 100 characters)');
        return;
    }
    
    if (jobId && dangerousPattern.test(jobId)) {
        alert('Job ID contains invalid characters');
        return;
    }

    let pieces = this.selectedPieces;
    const customPieces = parseInt(document.getElementById('custom-pieces')?.value);
    if (customPieces > 0) {
        pieces = customPieces;
    }
    
    if (pieces < 1 || pieces > 10000) {
        alert('Pieces per shipper must be between 1 and 10,000');
        return;
    }
    
    if (targetQty < 0 || targetQty > 1000000) {
        alert('Target quantity must be between 0 and 1,000,000');
        return;
    }

    try {
        const response = await fetch('/api/job/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                job_id: jobId || null,
                expected_barcode: expectedBarcode,
                pieces_per_shipper: pieces,
                target_quantity: targetQty
            })
        });

        const data = await response.json();

        if (data.error) {
            alert(data.error);
            return;
        }
        
        // ... rest of existing code
        
    } catch (err) {
        console.error('Failed to start job:', err);
        alert('Failed to start job: ' + err.message);
    }
}


################################################################################
# ADD FRIENDLY ERROR HANDLING IN main.py
################################################################################

# Add a custom exception handler for validation errors

# ADD THIS after app creation:
# ===========================================================================

from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle Pydantic validation errors with user-friendly messages"""
    errors = []
    for error in exc.errors():
        field = ' -> '.join(str(x) for x in error['loc'][1:])  # Skip 'body'
        message = error['msg']
        errors.append(f"{field}: {message}")
    
    logger.warning(f"Validation error from {request.client.host}: {errors}")
    
    return JSONResponse(
        status_code=422,
        content={
            'error': 'Invalid input data',
            'details': errors
        }
    )


################################################################################
# ADD HTML INPUT VALIDATION (templates/index.html)
################################################################################

# Add HTML5 validation attributes to inputs:
# ===========================================================================

# FIND the job-id input:
<input type="text" id="job-id" placeholder="Auto-generated if blank">

# REPLACE WITH:
<input 
    type="text" 
    id="job-id" 
    placeholder="Auto-generated if blank"
    maxlength="100"
    pattern="[^<>\"'&;\\]*"
    title="Letters, numbers, spaces, and basic punctuation only"
>

# FIND the expected-barcode input:
<input type="text" id="expected-barcode" placeholder="Scan or type" autofocus>

# REPLACE WITH:
<input 
    type="text" 
    id="expected-barcode" 
    placeholder="Scan or type" 
    autofocus
    required
    maxlength="200"
    pattern="[^<>\"'&;\\]+"
    title="Barcode required (max 200 characters)"
>

# FIND the custom-pieces input:
<input type="number" id="custom-pieces" placeholder="#" min="1">

# REPLACE WITH:
<input 
    type="number" 
    id="custom-pieces" 
    placeholder="#" 
    min="1" 
    max="10000"
    step="1"
    title="1 to 10,000 pieces"
>

# FIND the target-quantity input:
<input type="number" id="target-quantity" placeholder="No target" min="0">

# REPLACE WITH:
<input 
    type="number" 
    id="target-quantity" 
    placeholder="No target" 
    min="0" 
    max="1000000"
    step="1"
    title="0 to 1,000,000"
>


################################################################################
# TESTING
################################################################################

Test validation with curl:

# Test empty barcode
curl -X POST http://localhost:8000/api/job/start \
  -H "Content-Type: application/json" \
  -d '{"expected_barcode":"","pieces_per_shipper":1}'
# Expected: 422 error

# Test XSS attempt
curl -X POST http://localhost:8000/api/job/start \
  -H "Content-Type: application/json" \
  -d '{"expected_barcode":"<script>alert(1)</script>","pieces_per_shipper":1}'
# Expected: 422 error "invalid characters"

# Test too long barcode
curl -X POST http://localhost:8000/api/job/start \
  -H "Content-Type: application/json" \
  -d "{\"expected_barcode\":\"$(python -c 'print(\"A\"*201)')\",\"pieces_per_shipper\":1}"
# Expected: 422 error "too long"

# Test invalid pieces
curl -X POST http://localhost:8000/api/job/start \
  -H "Content-Type: application/json" \
  -d '{"expected_barcode":"TEST123","pieces_per_shipper":0}'
# Expected: 422 error "at least 1"

curl -X POST http://localhost:8000/api/job/start \
  -H "Content-Type: application/json" \
  -d '{"expected_barcode":"TEST123","pieces_per_shipper":99999999}'
# Expected: 422 error "10,000 or less"

# Test valid input
curl -X POST http://localhost:8000/api/job/start \
  -H "Content-Type: application/json" \
  -d '{"expected_barcode":"VALID123","pieces_per_shipper":5}'
# Expected: 200 success


################################################################################
# SECURITY NOTES
################################################################################

This patch protects against:
- XSS (Cross-Site Scripting) attacks
- SQL Injection (though SQLAlchemy already protects)
- Buffer overflow attempts
- Control character injection
- Excessively large inputs (DoS)

This does NOT protect against:
- CSRF (add CSRF tokens if needed)
- Rate limiting on job creation (add separately if needed)
- Advanced encoding attacks (should be handled at proxy level)


################################################################################
# ROLLBACK
################################################################################

To rollback:
1. Remove validators from models.py
2. Remove exception handler from main.py
3. Revert HTML input attributes
4. Remove client-side validation from app.js

Application will work without validation but be vulnerable to bad input.
