################################################################################
# PATCH #1: ADD LOGGING SYSTEM
# Priority: CRITICAL
# Time to apply: 5 minutes
################################################################################

DESCRIPTION:
Adds comprehensive logging system to track all operations and debug production issues.

FILES TO MODIFY:
1. main.py

DEPENDENCIES:
None - uses Python standard library

################################################################################
# CHANGES TO main.py
################################################################################

# ADD THESE IMPORTS AT THE TOP (after existing imports, before app creation)
# ===========================================================================

import logging
from logging.handlers import RotatingFileHandler
import os

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
log_file = os.environ.get('LOG_FILE', 'barcode_verification.log')

# Create logs directory if it doesn't exist
os.makedirs('logs', exist_ok=True)

logging.basicConfig(
    level=getattr(logging, log_level),
    format='%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',
    handlers=[
        RotatingFileHandler(
            f'logs/{log_file}',
            maxBytes=10485760,  # 10MB
            backupCount=5,
            encoding='utf-8'
        ),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)
logger.info("=" * 80)
logger.info("Barcode Verification System Starting")
logger.info(f"Log level: {log_level}")
logger.info("=" * 80)


# MODIFY LIFESPAN FUNCTION
# ===========================================================================
# FIND:
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    shutdown_event.clear()
    SQLModel.metadata.create_all(engine)

# REPLACE WITH:
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("Application startup initiated")
    shutdown_event.clear()
    
    try:
        SQLModel.metadata.create_all(engine)
        logger.info("Database tables created/verified")
    except Exception as e:
        logger.error(f"Failed to create database tables: {e}", exc_info=True)
        raise
    
    # Ensure ShiftStats for today exists
    with Session(engine) as session:
        today = datetime.now().date()
        stats = session.exec(select(ShiftStats).where(ShiftStats.date == today)).first()
        if not stats:
            try:
                stats = ShiftStats(date=today)
                session.add(stats)
                session.commit()
                logger.info(f"Created ShiftStats for {today}")
            except IntegrityError:
                session.rollback()
                logger.debug("ShiftStats already exists (race condition)")
    
    logger.info("Application startup complete")
    yield
    
    # Shutdown
    logger.info("Application shutdown initiated")
    shutdown_event.set()
    gpio_controller.cleanup()
    logger.info("Application shutdown complete")


# ADD LOGGING TO CRITICAL ENDPOINTS
# ===========================================================================

# MODIFY start_job endpoint - ADD logging
# FIND:
@app.post("/api/job/start")
async def start_job(request: JobStartRequest, session: Session = Depends(get_session)):
    # Check active
    active = session.exec(select(Job).where(Job.is_active == True)).first()

# REPLACE WITH:
@app.post("/api/job/start")
async def start_job(request: JobStartRequest, session: Session = Depends(get_session)):
    logger.info(f"Job start request: job_id={request.job_id}, barcode={request.expected_barcode[:20]}...")
    
    try:
        # Check active
        active = session.exec(select(Job).where(Job.is_active == True)).first()
        
        if active:
            logger.warning(f"Cannot start job - active job exists: {active.job_id}")
            return JSONResponse(status_code=400, content={'error': 'A job is already active. End it first.'})
        
        # ... rest of existing code until job creation ...
        
        session.add(job)
        session.commit()
        session.refresh(job)
        
        logger.info(f"Job started successfully: job_id={job.job_id}, id={job.id}")
        
    except Exception as e:
        logger.error(f"Failed to start job: {e}", exc_info=True)
        session.rollback()
        raise


# MODIFY process_scan endpoint - ADD logging
# FIND:
@app.post("/api/scan", response_model=ScanResultResponse)
async def process_scan(request: ScanRequest, session: Session = Depends(get_session)):
    barcode = request.barcode.strip()
    if not barcode:
        return JSONResponse(status_code=400, content={'error': 'No barcode provided'})
    
    job = session.exec(select(Job).where(Job.is_active == True)).first()

# REPLACE WITH:
@app.post("/api/scan", response_model=ScanResultResponse)
async def process_scan(request: ScanRequest, session: Session = Depends(get_session)):
    barcode = request.barcode.strip()
    logger.debug(f"Scan request: barcode={barcode[:20]}...")
    
    try:
        if not barcode:
            logger.warning("Empty barcode received")
            return JSONResponse(status_code=400, content={'error': 'No barcode provided'})
        
        job = session.exec(select(Job).where(Job.is_active == True)).first()
        if not job:
            logger.error("Scan attempted with no active job")
            return JSONResponse(status_code=400, content={'error': 'No active job'})
        
        status = 'PASS' if barcode == job.expected_barcode else 'FAIL'
        logger.info(f"Scan processed: job={job.job_id}, status={status}, barcode={barcode[:20]}...")
        
        # ... rest of existing code ...
        
    except Exception as e:
        logger.error(f"Scan processing failed: {e}", exc_info=True)
        raise


# MODIFY end_job endpoint - ADD logging
# FIND:
@app.post("/api/job/end", response_model=JobEndResponse)
async def end_job(request: JobEndRequest, session: Session = Depends(get_session)):
    if request.pin != SUPERVISOR_PIN:
        return JSONResponse(status_code=403, content={'error': 'Invalid supervisor PIN'})

# REPLACE WITH:
@app.post("/api/job/end", response_model=JobEndResponse)
async def end_job(request: JobEndRequest, session: Session = Depends(get_session)):
    logger.info("Job end request received")
    
    try:
        if request.pin != SUPERVISOR_PIN:
            logger.warning("Failed job end attempt - invalid PIN")
            return JSONResponse(status_code=403, content={'error': 'Invalid supervisor PIN'})
        
        job = session.exec(select(Job).where(Job.is_active == True)).first()
        if not job:
            logger.error("Job end attempted with no active job")
            return JSONResponse(status_code=400, content={'error': 'No active job'})
        
        # ... existing code ...
        
        session.commit()
        session.refresh(job)
        
        logger.info(f"Job ended: job_id={job.job_id}, scans={job.total_scans}, pass_rate={job.pass_rate:.1f}%")
        
    except Exception as e:
        logger.error(f"Job end failed: {e}", exc_info=True)
        session.rollback()
        raise


# ADD ERROR LOGGING ENDPOINT (optional but useful)
# ===========================================================================
# ADD THIS NEW ENDPOINT:

@app.post("/api/log_error")
async def log_client_error(request: Request):
    """Log JavaScript errors from client"""
    try:
        data = await request.json()
        error_msg = data.get('error', 'Unknown error')
        stack = data.get('stack', 'No stack trace')
        logger.error(f"Client-side error: {error_msg}\nStack: {stack}")
        return {"status": "logged"}
    except Exception as e:
        logger.error(f"Failed to log client error: {e}")
        return {"status": "failed"}


################################################################################
# TESTING
################################################################################

After applying this patch:

1. Start the application
2. Check that logs/barcode_verification.log is created
3. Verify logs are written for each operation
4. Test log rotation by generating >10MB of logs

################################################################################
# ROLLBACK
################################################################################

To rollback, remove all logging-related code added above.
The application will still work, just without logging.
